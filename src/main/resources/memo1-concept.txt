// jwt


JWT 개념 (로그인 개념)
JWT 기본 사용법 (readme)
JWT 실제 구현체
JWT 프론트단 조작법





https://www.youtube.com/watch?v=1QiOXWEbqYQ

어떤 문제를 해결하려고 JWT 가 나왔을까?
기술은 어떤 문제를 해결하려고 노력하는 과정에서 발전한다.
JWT 는 로그인에 쓰는 기술이다.
그러니까 로그인 기술을 봐야 한다.
이전에 쓰던 로그인 기술은 세션이다.
세션을 쓰는 로그인 기술에 어떤 문제점이 있었다.
그러니까 그걸 해결하려고 JWT 가 나왔겠지.
그럼 세션에는 어떤 문제점이 있었을까?
그러면 일단 로그인 기능이 작동하는 전체적인 방식을 알아야겠다.
로그인 기능 자체만 생각해 보면 쉽다.
아이디랑 패스워드만 보내고 그게 맞는지 확인만 하면 되니까.
관건은 그걸 유지하는 기능이다.
우리가 보통 사이트에서 어떻게 하는지 생각해 보면 안다.
아이디/패스워드를 치고 로그인하는 건 한 번이다.
한 번만 로그인 하고 나면 그 다음부터는 로그인 한 상태가 유지된다.
로그인하는 사용자가 맞는지 증명하는 일을 '인증' 이라고 하고
로그인을 유지하면서 여러 활동을 하도록 허가하는 일을 '인가'라고 한다.
(https://www.youtube.com/watch?v=1QiOXWEbqYQ)
글을 읽을 때, 댓글을 달 때, 수정할 때, 페이지를 넘어갈 때,
뭐 행동 하나마다 아이디와 패스워드를 치지는 않는다.
요청 하나마다 아이디와 패스워드를 확인하는 방법은 안 좋다.
보안에도 좋지 않고 성능에도 좋지 않다.
요청마다 서버와 클라이언트 사이로 아이디/패스워드가 오고 가니 보안에 좋지 않다.
또 요청 받은 아이디/패스워드를 들고서 서버가 데이터베이스까지 가서 맞는지 틀린지 확인하려면 성능에도 좋지 않다.
그래서 세션 같은 로그인 기술을 쓰게 됐다.
일단 로그인하는 단계까지는 똑같다.
사용자가 입력한 아이디와 패스워드를 서버가 받아서 데이터베이스까지 가서 확인한다.
대신 그 이후부터가 다르다.
만약 로그인 정보가 맞으면 서버는 그 로그인 정보를 서버에 저장해 둔다.
아이디, 로그인한 지역, 로그인한 시각, 로그인한 기기 등등...
그리고 저장해 둔 로그인 정보를 찾을 수 있는 어떤 딱지를 만든다.
로그인한 클라이언트에게는 이 딱지를 돌려준다.
클라이언트는 딱지를 받아서 보관하고 있다가 서버에 요청할 때마다 딱지를 함께 보낸다.
비유해서 딱지이지 사실은 "UtleUlkIiwieDV1IjoidGhpcy1pc" 이런 이상한 문자열이다.
요청마다 아이디와 패스워드를 주고 받는 대신 이 이상한 문자열을 주고 받기로 한다.
중간에 누군가 가로채더라도 상대적으로 안전하다.
그러면 서버는 이 딱지를 가지고 뭘 하는가?
클라이언트가 요청을 보낼 때 이 딱지를 함께 제출하면 서버는 이 딱지를 가지고 서버에 저장해 두었던 로그인 정보를 불러온다.
로그인 정보를 바탕으로 사용자가 유효한 로그인 사용자인지 확인한다.
말하자면 서랍에 이름표를 붙여둔 것과 같다.
사용자가 로그인하면 서버는 어떤 서랍 안에다가 로그인 정보를 보관해 두고 그 서랍 손잡이에 이름표를 붙여둔다.
그리고 똑같은 이름표를 사용자에게도 하나 주는 방식이다.
이 이름표가 로그인 딱지다.
이러한 세션 방식은 장점도 많다.
로그인 정보를 서버가 데이터베이스 안에 모두 저장해 두고 있기 때문이다.
정보가 서버에 저장돼 있다는 말은 서버가 로그인을 관리할 수 있다는 말이다.
어떤 사용자가 어디에서 접속해 있는지 알 수 있다.
동시에 몇 명이 로그인하고 있는지도 알 수 있다.
임의로 어떤 사용자의 로그인 상태를 무효화할 수 있다.
'로그인한 기기 보기' 같은 기능도 서버에서 로그인 정보를 관리하고 있기 때문에 가능하다.
로그인 정보가 서버 쪽에 있기 때문에 누군가 조작하기도 어렵다.
이렇게 좋은데 무슨 문제가 있길래 JWT가 나왔을까.
역시나 성능 문제다.
물론 로그인한 사용자들을 서버에서 모두 관리할 수 있다면 정말 좋겠다.
하지만 사용자가 많아지면 많아질수록 부담이 될 수 밖에 없다.
로그인한 모든 사용자들의 정보를 어딘가에 보관하고 있어야 한다.
서버마다 직접 들고 있을 수는 없다.
stateful 해지기 때문이다.
서비스 규모가 커지면 서버를 여러 대 두고 운영한다.
이때 A서버에 로그인 정보가 저장돼 있다면 B서버에서는 로그인한 사용자를 알 수 없다.
따라서 모든 서버가 함께 접근할 수 있는 저장소를 공유해야 한다.
그것이 바로 데이터베이스다.
로그인 정보를 데이터베이스에 저장하거나 불러오기를 반복한다.
그래서 세션 방식은 성능 면에서 좋지 못하다.
데이터베이스에 저장할 데이터도 많아지고 계속 왔다 갔다 해야 하니까 말이다.
DB에 왔다 갔다 하는 과정을 조금 줄여 보고자 만든 게 JWT 다.
JWT 를 써서 로그인 기능을 만들면 뭐가 다를까?
일단 인증 기능까지는 어쩔 수 없이 똑같겠지.
사용자가 아이디와 패스워드를 입력하면 데이터베이스까지 가서 맞는지 확인해야 한다.
로그인한 사용자가 맞다면 딱지를 준다.
그리고 요청을 보낼 때마다 이 딱지를 함께 보낸다.
여기까지는 세션을 쓰는 방식과 비슷하다.
다른 건 딱지에 쓰인 내용이다.
세션을 쓰면 딱지는 단순히 로그인 정보를 어떤 서랍에 넣어뒀는지 찾는 용도였다.
사용자가 로그인한 정보는 서버에 저장했다.
반면에 JWT 를 쓰면 로그인 정보를 서버가 아니라 클라이언트가 들고 있도록 만든다.
이 딱지를 누가 발급했고, 누구한테 발급했고, 언제까지 쓸 수 있고....
그걸 모두 딱지에 써 놓는다.
그러면 서버는 데이터베이스까지 가지 않고 딱지만 확인한다.
딱지에 누가 로그인한 건지, 유효한 로그인인지 다 써 있기 때문이다.
그러면 좋은 점은 일단 가벼워진다.
로그인 정보를 클라이언트가 들고 있기 때문이다.
데이터베이스까지 다녀올 필요가 없어진다.
로그인한 사용자가 많고 요청이 쏟아져도 빨리빨리 처리할 수 있다.
세션을 쓰면 로그인 정보를 확인하려고 서랍을 일일이 열어 봐야 했지만 JWT 를 쓰면 그럴 필요가 없기 때문이다.
또 stateless 하다.
사용자가 많고 서버가 커지면 서버를 여러 대 둔다.
A서버가 발급한 딱지를 B서버가 처리하기도 한다.
요청을 A서버가 받았는데 필요한 정보는 B서버에 있다면?
돌아서 가야 하기 때문에 처리가 많이 늦어진다.
JWT 를 쓰면 그럴 일이 없다.
필요한 정보를 모두 딱지 안에 적어 두었기 때문이다.

그런데 가장 먼저 떠오르는 문제점은 조작 위험이다.
딱지에 써 놓은 내용을 마음대로 바꿔서 요청을 보내면?
다른 사람인 척 딱지를 내밀면서 요청을 보내면?
그래서 딱지 위에 일종의 도장을 찍는다.
비유하자면 먼저 서류를 작성하고 나서 그 위에 워터 마크를 찍는다고 생각하면 된다.
JWT 에서는 이 부분을 시그니처라고 한다.
나만 알고 있는 비밀키로 데이터를 가공해 시그니처를 만든다.
데이터를 수정하면 시그니처도 함께 바뀐다.
따라서 시그니처를 확인해 보면 내가 처음에 인증해 준 데이터가 그대로인지 아니면 중간에 바뀌었는지 알 수 있다.
이 시그니처를 토큰에 담아두고 요청을 주고 받을 때마다 확인하면 된다.
그러면 데이터를 조작했는지 여부를 바로 알 수 있다.

그런데 이런 방식을 쓰면 또 다른 위험이 있다.
나만 알고 있는 줄 알았던 비밀키가 유출되는 것이다.
생각해 보자.
비밀키 하나로 평생을 쓴다면 누군가 알아맞히든 정보가 새어나가든 할 것이다.
그래서 비밀키를 계속해서 바꾼다.
비밀키가 새어나가더라도 이미 새로운 비밀키를 사용하고 있으니 소용이 없다.
비밀키를 자주 바꿀수록 안전할 것이다.

정리하자면 이렇다.
사용자가 요청한 로그인 정보가 맞다면 딱지를 준다.
그 딱지 안에 로그인 정보를 적어두고 사용자가 들고 있도록 만든다.
로그인 정보를 서버에 저장하지 않고 사용자가 들고 다니면 조작 당할 위험이 있다.
조작을 방지하려고 데이터를 나만 알고 있는 비밀키로 가공해서 시그니처를 만든다.
그러면 데이터가 조작되더라도 시그니처를 보고 조작된 데이터인지 알 수 있다.
하지만 한 비밀키를 오래 사용하면 유출된 위험이 점점 높아진다.
비밀키가 새어나갈 경우를 대비해서 비밀키를 계속해서 바꾼다.

그런데 비밀키를 바꾸면 또 다른 문제가 있다.
비밀키를 바꾸고 나면 이전에 로그인 했던 사람들은 다시 로그인을 해야 한다.
비밀키가 바뀌면 시그니처도 따라서 달라지기 때문이다.
그러면 로그인 상태를 유지하려고 만든 인가 기술이 의미를 잃는다.

이 문제를 해결하려고 토큰을 하나 더 만든다.
하나는 유효 기간이 짧은 토큰, 다른 하나는 유효 기간이 긴 토큰이다.
유효 기간이 짧은 토큰은 access 토큰, 긴 쪽은 refesh 토큰이라고 한다.
서버는 사용자가 로그인에 성공했을 때 refresh 토큰와 access 토큰을 둘 다 만든다.
access 토큰은 서버에 저장하지 않지만 refresh 토큰은 서버에 저장해 둔다.
클라이언트를 유효 기간이 짧은 access 토큰만 가지고 요청을 보내다가
유효 기간이 지나고 나면 refesh 토큰을 보낸다.
서버는 가지고 있던 refresh 토큰을 확인해 보고 새로운 access 토큰을 발급해 준다.
이후에는 다시 access 토큰만 주고 받으며 통신한다.
만약에 유출됐다고 의심되는 토큰이 있다면 서버는 refresh 토큰을 지워버리면 된다.

어떻게 보면 JWT 방식도 세션 방식으로 만든 인가 기술과 비슷한다.
사용자가 로그인에 성공하면 서버는 로그인 정보를 데이터베이스에 저장해 둔다.
JWT 방식은 refresh 토큰으로, 세션 방식은 세션 정보로 저장한다.
다만 다른 점이 있다면 주고 받는 정보의 깊이가 다르다.
세션 방식은 서버와 클라이언트가 세션ID를 직접 주고 받지만
JWT 방식은 refresh 토큰은 그대로 두고 access 토큰만 주고 받는다.





